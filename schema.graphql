# See Types in: https://thegraph.com/docs/define-a-subgraph
#   - Bytes: Byte array, represented as a hexadecimal string. Commonly used for Ethereum hashes and addresses
#   - ID:	Stored as a string
#   - string: Scalar for string values
#   - boolean: Scalar for boolean values
#   - Int	The GraphQL spec defines Int to have size of 32 bytes
#   - BigInt	Arbitrarily large integers. Used for Ethereum's uint32, int64, uint64, ..., uint256 types. Note: Everything below uint32, such as int32, uint24 or int8 is represented as i32.
#   - BigDecimal	BigDecimal is used to represent arbitrary precision decimals

type Token @entity {
  id: ID! # tokenId
  address: Bytes!
  fromBatchId: BigInt!

  # token details (optional)
  symbol: String
  decimals: Int
  name: String

  # Balances and Deposits
  balances: [Balance!]! @derivedFrom(field: "token")
  deposits: [Deposit!]! @derivedFrom(field: "token")

  # Audit Dates
  createEpoch: BigInt!

  # Transaction
  txHash: Bytes!
}

type User @entity {
  id: ID! # address

  # Balances and Deposits
  balances: [Balance!]! @derivedFrom(field: "user")
  deposits: [Deposit!]! @derivedFrom(field: "user")

  # Audit Dates
  createEpoch: BigInt!

  # Transaction
  txHash: Bytes!
}

type Balance @entity {
  id: ID! # user-token
  user: User!
  token: Token!

  # Audit Dates
  createEpoch: BigInt!
  updateEpoch: BigInt!
}

type Deposit @entity {
  id: ID! # user-token
  user: User!
  token: Token!
  amount: BigInt!
  batchId: BigInt!

  # Audit Dates
  createEpoch: BigInt!

  # Transaction
  txHash: Bytes!
}

type Order @entity {
  id: ID! # ownerAddress + orderId
  owner: Bytes! # address - TODO: User
  orderId: Int! # uint16

  # Validity
  fromBatchId: BigInt! # uint32
  fromEpoch: BigInt!
  untilBatchId: BigInt! # uint32
  untilEpoch: BigInt!

  # Tokens
  buyToken: Token!
  sellToken: Token!

  # Price
  priceNumerator: BigInt! # uint128
  priceDenominator: BigInt! # uint128

  # Traded amounts
  maxSellAmount: BigInt!
  soldVolume: BigInt!
  boughtVolume: BigInt!
  trades: [Trade!]! @derivedFrom(field: "order")

  # Audit Dates
  createEpoch: BigInt!
  cancelEpoch: BigInt
  deleteEpoch: BigInt

  # Transaction
  txHash: Bytes!,
  txLogIndex: BigInt!
}

type Trade @entity {
  id: ID! # ownerAddress + orderId
  order: Order!

  # Trade details
  sellVolume: BigInt!
  buyVolume: BigInt!
  tradeBatchId: BigInt
  tradeEpoch: BigInt

  # Audit Dates
  #   Note that "createEpoch" is different from "tradeEpoch", since "tradeEpoch" is the end of the batch, and the 
  #   "createEpoch" is the date where the transaction was mined
  createEpoch: BigInt!
  revertEpoch: BigInt
  
  # Transaction
  txHash: Bytes!,
  txLogIndex: BigInt!
}